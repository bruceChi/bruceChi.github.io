<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Stay hungry Stay young</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Stay hungry Stay young">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Stay hungry Stay young">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stay hungry Stay young">
  
    <link rel="alternate" href="/atom.xml" title="Stay hungry Stay young" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Stay hungry Stay young</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-浅谈netty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/03/浅谈netty/" class="article-date">
  <time datetime="2019-08-03T10:12:33.354Z" itemprop="datePublished">2019-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/03/浅谈netty/">浅谈netty</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要理解netty，我们需要先了解I/O Models和JAVA NIO，还有观察者模式、多Reactors线程模型等等这些内容。</p>
<h1 id="I-O-Models"><a href="#I-O-Models" class="headerlink" title="I/O Models"></a>I/O Models</h1><p>在这里我们先要回顾一些操作系统的IO相关基础知识：</p>
<ul>
<li>用户空间与内核空间:<br>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</li>
<li>系统调用：<br>Linux/Unix内核中设置了一组用于实现各种系统功能的子程序，称为系统调用。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态；而普通的函数调用由函数库或用户自己提供，运行于用户态。</li>
<li>进程切换：</li>
</ul>
<p>1.为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。<br> 2.消耗CPU资源。</p>
<ul>
<li>进程的阻塞:</li>
</ul>
<p>1.正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<br>2.当进程进入阻塞状态，不消耗CPU资源。</p>
<ul>
<li>文件描述符：</li>
</ul>
<p>1.文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>2.文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<ul>
<li>缓存 I/O：</li>
</ul>
<p>1.缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。<br>2.缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<p><strong>当一个输入（input）操作发生时，这里会经历两个不同的阶段：</strong><br>1.等待数据就绪。<br>2.将数据从内核的缓冲区拷贝到进程中。</p>
<p><strong>下面是5种IO模型</strong><br>      1.blocking I/O<br>      2.nonblocking I/O<br>      3.I/O multiplexing (select and poll)<br>      4.signal driven I/O (SIGIO)<br>      5.asynchronous I/O (the POSIX aio_functions)</p>
<h5 id="Blocking-I-O-Model"><a href="#Blocking-I-O-Model" class="headerlink" title="Blocking I/O Model"></a>Blocking I/O Model</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-decfd9efba7065b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>整个读取IO的数据是同步、阻塞的。</p>
<h5 id="Nonblocking-I-O-Model"><a href="#Nonblocking-I-O-Model" class="headerlink" title="Nonblocking I/O Model"></a>Nonblocking I/O Model</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-34d279e2a714d524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当一个应用程序像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询(polling)，应用程序持续轮询内核，以查看某个操作是否就绪，这么做往往耗费大量CPU时间。通常是在专门提供某一种功能的系统中才有</p>
<h5 id="I-O-Multiplexing-Model"><a href="#I-O-Multiplexing-Model" class="headerlink" title="I/O Multiplexing Model"></a>I/O Multiplexing Model</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-824805ab3202d48a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>在IO复用中，我们调用select或者poll 然后在这两个系统调用中的一个中阻塞，而不是阻塞在真实的I/O系统调用上。</li>
<li>优势：跟阻塞I/O模型比较使用select我们可以等待多个描述符就绪，也就是一个线程可以处理多个描述符。<h5 id="signal-driven-I-O-SIGIO"><a href="#signal-driven-I-O-SIGIO" class="headerlink" title="signal driven I/O (SIGIO)"></a>signal driven I/O (SIGIO)</h5><img src="https://upload-images.jianshu.io/upload_images/15507353-76d334e3648b45d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。</li>
<li>优势：等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知（既可以是数据已准备好被处理，也可以是数据报已准备好被读取。）<h5 id="asynchronous-I-O-the-POSIX-aio-functions"><a href="#asynchronous-I-O-the-POSIX-aio-functions" class="headerlink" title="asynchronous I/O (the POSIX aio_functions)"></a>asynchronous I/O (the POSIX aio_functions)</h5>告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。通过状态、通知和回调来通知调用者的输入输出操作。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/15507353-46f7363c8f48887d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>优势：<br>我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，病告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。<h5 id="各种I-O模型的比较"><a href="#各种I-O模型的比较" class="headerlink" title="各种I/O模型的比较"></a>各种I/O模型的比较</h5><img src="https://upload-images.jianshu.io/upload_images/15507353-fb6ab70d35a5ec6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>前4中模型的主要区别在于第一阶段，因为它们的第二阶段是一样的：在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用。</li>
<li>同步I/O操作导致请求进程阻塞，直到I/O操作完成，异步I/O操作不导致请求进程阻塞。前四种都是同步I/O模型，因为其中的I/O操作recvfrom讲阻塞进程。只有异步I/O模型与POSIX定义的异步I/O相匹配。</li>
</ul>
<p>随着linux内核的不断发展，IO也在不断发展，所以后面有了IO多路复用模型。IO 多路复用是通过linux内核的select、poll、epoll这些来完成的。</p>
<h6 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h6><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。<br>       例如：我们可以调用select，告知内核仅在下列情况发生时才返回：</p>
<ul>
<li>集合{1,4,5}中的任何描述符准备好读；</li>
<li>集合{2,7}中任何描述符准备好写；</li>
<li>集合{1,4}中的任何描述符有异常条件待处理；</li>
<li>已经历了10.2秒<br>下面是select函数的简单结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">//返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span><br><span class="line">int select(int maxfdp1,fd_set *readset,fd_set *writeset, fd_set *exceptest,const struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">struct timeval&#123;</span><br><span class="line">    long tv_sec;       /* seconds */</span><br><span class="line">    long tv_used;    /* microseconds */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求<br>pselect : 能够处理信号阻塞并提供了更高时间分辨率的select的增强版本 </p>
<h6 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">//返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span><br><span class="line">int poll (struct pollfd *fdarray, unsigned long nfds, int timeout);</span><br><span class="line"></span><br><span class="line">//一个pollfd结构体表示一个被监视的文件描述符</span><br><span class="line">struct pollfd &#123;</span><br><span class="line">int fd; /* descriptor to check */</span><br><span class="line">short events; /* events of interest on fd */</span><br><span class="line">short revents; /* events that occurred on fd */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>select机制的问题<br>     1.每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大<br>     2.同时每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大<br>     3.为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)    【poll用数组结构体解决了大小限制问题】</p>
<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一些缺点：</p>
<ul>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
</ul>
<h6 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h6><p>epoll在Linux2.6内核正式提出，是基于事件驱动的I/O方式，相对于select来说，epoll没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);  // epoll_create 函数创建一个epoll句柄</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epoll_ctl 函数注册要监听的事件类型</span><br><span class="line">//  epoll_wait 函数等待事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br><span class="line">struct epoll_event &#123;    </span><br><span class="line">    __uint32_t events;  /* Epoll events */    </span><br><span class="line">    epoll_data_t data;  /* User data variable */&#125;;</span><br><span class="line"></span><br><span class="line">typedef union epoll_data &#123;    </span><br><span class="line">   void *ptr;   </span><br><span class="line">    int fd;    </span><br><span class="line">    __uint32_t u32;   </span><br><span class="line">    __uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br></pre></td></tr></table></figure>

<p>epoll优点：<br>1.没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2.效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>
<ol start="3">
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li>
</ol>
<p>它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<p>对比：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-852aeb1306cad363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p>
<p>1.表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
<p>2.select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p>
<h1 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h1><p>Java NIO提供了与标准IO不同的IO工作方式：</p>
<ul>
<li><p><strong><em>Channels and Buffers（通道和缓冲区）：</em></strong></p>
<pre><code>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</code></pre></li>
<li><p><strong><em>非阻塞IO（Non-blocking IO）：</em></strong></p>
<pre><code>Java NIO可以让执行非阻塞IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</code></pre></li>
<li><p><strong><em>选择器（Selectors）：</em></strong></p>
<pre><code>Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。</code></pre></li>
</ul>
<p>java nio 的几个重要组件：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-b31d784b48dadc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="Channels-and-Buffers"><a href="#Channels-and-Buffers" class="headerlink" title="Channels and Buffers"></a>Channels and Buffers</h3><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-260d5035da805295.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>常见的几种channel:</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel  UDP连接</li>
<li>SocketChannel 客户端socket连接</li>
<li>ServerSocketChannel 服务端socket连接</li>
</ul>
<p>常见的几种Buffer:</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
<li>Mappedyteuffer 表示内存映射文件 java nio 提供了这个在某种场景下极大提升效率</li>
</ul>
<h6 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h6><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-d28a4134e88df482.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>A Thread uses a Selector to handle 3 Channel&apos;s </code></pre><h5 id="IO-VS-NIO"><a href="#IO-VS-NIO" class="headerlink" title="IO VS NIO"></a>IO VS NIO</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-ce1f5858d4ae790b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="netty原理"><a href="#netty原理" class="headerlink" title="netty原理"></a>netty原理</h3><p>Netty是一个事件驱动、异步IO的网络框架。高性能，吞吐量更高，延迟更低、高性能之处主要来自于其I/O 模型和线程处理模型(Reactor)，前者决定如何收发数据，后者决定如何处理数据。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-55e3375574c52e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h6><p><img src="https://upload-images.jianshu.io/upload_images/15507353-443bc0e11a9eba93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Reactor模式(反应器模式)是一种处理一个或多个客户端并发交付服务请求的事件设计模式。当请求抵达后，服务处理程序使用I/O多路复用策略，然后同步地派发这些请求至相关的请求处理程序。</p>
<p><strong><em>核心组件交互图如下：</em></strong><br><img src="https://upload-images.jianshu.io/upload_images/15507353-e7685f3c6ba9bcbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><strong><em>Handle(句柄或描述符，在Windows下称为句柄，在Linux下称为描述符)：</em></strong>本质上表示一种资源(比如说文件描述符，或是针对网络编程中的socket描述符)，是由操作系统提供的；该资源用于表示一个个的事件，事件既可以来自于外部，也可以来自于内部。</li>
<li><strong><em>Synchronous Event Demultiplexer(同步事件分离器)：</em></strong>它本身是一个系统调用，用于等待事件的发生(事件可能是一个，也可能是多个)。调用方在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I/O多路复用机制，比如说select、poll、epoll等。在Java NIO领域中，同步事件分离器对应的组件就是Selector；对应的阻塞方法就是select方法。</li>
<li><strong><em>Event Handler(事件处理器)：</em></strong>本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。在Java NIO领域中并没有提供事件处理器机制让我们调用或去进行回调，是由我们自己编写代码完成的。Netty相比于Java NIO来说，在事件处理器这个角色上进行了一个升级，它为我们开发者提供了大量的回调方法，供我们在特定事件产生时实现相应的回调方法进行业务逻辑的处理，即ChannelHandler。ChannelHandler中的方法对应的都是一个个事件的回调。</li>
<li><strong><em>Initiation Dispatcher(初始分发器):</em></strong>际上就是Reactor角色。它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册、删除等设施。它本身是整个事件处理器的核心所在，Initiation Dispatcher会通过Synchronous Event Demultiplexer来等待事件的发生。一旦事件发生，Initiation Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。Netty中ChannelHandler里的一个个回调方法都是由bossGroup或workGroup中的某个EventLoop来调用的。</li>
</ul>
<h5 id="Basic-Reactor-Design"><a href="#Basic-Reactor-Design" class="headerlink" title="Basic Reactor Design"></a>Basic Reactor Design</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-5df6e05a83dc5945.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="NIO实现Reactor"><a href="#NIO实现Reactor" class="headerlink" title="NIO实现Reactor"></a>NIO实现Reactor</h6><p><img src="https://upload-images.jianshu.io/upload_images/15507353-db75d724aa5f6db9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-5bb1f9485cb1a07b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15507353-a53c90380c390c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-07ddccf1a37c26a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-e2cb5f543d7d9ae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上面是用java nio实现基本Reactor模式，需要自己写很多代码。</p>
<h6 id="Worker-Thread-Poll-版-Reactor模式"><a href="#Worker-Thread-Poll-版-Reactor模式" class="headerlink" title="Worker Thread Poll 版 Reactor模式"></a>Worker Thread Poll 版 Reactor模式</h6><p><img src="https://upload-images.jianshu.io/upload_images/15507353-3c376476b20d784f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="多Reactor模式"><a href="#多Reactor模式" class="headerlink" title="多Reactor模式"></a>多Reactor模式</h6><p><img src="https://upload-images.jianshu.io/upload_images/15507353-86328d64eb66fe59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><em>netty就是使用的就是多Reactor模式：</em></strong><br><img src="https://upload-images.jianshu.io/upload_images/15507353-f4ab71b11b50b707.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="Netty的异步处理："><a href="#Netty的异步处理：" class="headerlink" title="Netty的异步处理："></a>Netty的异步处理：</h6><p><img src="https://upload-images.jianshu.io/upload_images/15507353-ef58694de510130b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong><em>常见操作：</em></strong><br><img src="https://upload-images.jianshu.io/upload_images/15507353-ba866ab661f4a1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="netty功能特性"><a href="#netty功能特性" class="headerlink" title="netty功能特性"></a>netty功能特性</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-1ce0568318af538e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-0fbe146884fe1a30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="ChannelPipeline处理入站事件和出站操作"><a href="#ChannelPipeline处理入站事件和出站操作" class="headerlink" title="ChannelPipeline处理入站事件和出站操作"></a>ChannelPipeline处理入站事件和出站操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-73f9d820cd920b58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-8e50fc6be26fbef5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-607d208786174743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="Netty-Reactor-工作架构图"><a href="#Netty-Reactor-工作架构图" class="headerlink" title="Netty Reactor 工作架构图"></a>Netty Reactor 工作架构图</h5><p><img src="https://upload-images.jianshu.io/upload_images/15507353-3a5b02adeaa394ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-814edca973a0e5e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-c0899726b4bf7b4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下面有一个基于netty的简单的IM demo,可以简单了解netty的编程方法和思想：<br>Server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.im.netty.server;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelOption;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line">import io.netty.handler.codec.string.StringDecoder;</span><br><span class="line">import io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by bruce on 2019/6/10.</span><br><span class="line"> */</span><br><span class="line">public class Server &#123;</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    public Server(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line"></span><br><span class="line">        // netty服务端ServerBootstrap启动的时候,默认有两个eventloop分别是bossGroup和 workGroup</span><br><span class="line"></span><br><span class="line">        EventLoopGroup boosGroup = new NioEventLoopGroup(1);   // bossGroup</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();  // workGroup</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerBootstrap sbs = new ServerBootstrap().group(boosGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .localAddress(new InetSocketAddress(port))</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(&quot;decoder&quot;, new StringDecoder());</span><br><span class="line">                            ch.pipeline().addLast(&quot;encoder&quot;, new StringEncoder());</span><br><span class="line">                            //ch.pipeline().addLast(new DiscardInboundHandler());</span><br><span class="line">                            ch.pipeline().addLast(new ServerHandler());</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;).option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, true);</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = sbs.bind(port).sync();</span><br><span class="line">            System.out.println(&quot;Server start listen at &quot; + port);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            boosGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        int port;</span><br><span class="line">        if (args.length &gt; 0) &#123;</span><br><span class="line">            port = Integer.parseInt(args[0]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            port = 8090;</span><br><span class="line">        &#125;</span><br><span class="line">        new Server(port).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.im.netty.client;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.channel.*;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line">import io.netty.handler.codec.string.StringDecoder;</span><br><span class="line">import io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by bruce on 2019/6/10.</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    //server &apos;s ip 这里需要用户根据自己server的ip来做修改,例如我这里是10.1.132.194</span><br><span class="line">    private static final String HOST = System.getProperty(&quot;host&quot;, &quot;10.1.132.194&quot;);</span><br><span class="line">    //port 8090</span><br><span class="line">    private static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8090&quot;));</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap b = new Bootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline p = ch.pipeline();</span><br><span class="line">                            p.addLast(&quot;decoder&quot;, new StringDecoder());</span><br><span class="line">                            p.addLast(&quot;encoder&quot;, new StringEncoder());</span><br><span class="line">                            p.addLast(new ClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = b.connect(HOST, PORT).sync();</span><br><span class="line">            //控制台输入消息给服务端让服务端转给给另外一个客户端</span><br><span class="line">            //消息如:  认识你真高兴我的小伙伴@10.1.8.30</span><br><span class="line">            //消息就转发给了10.1.8.30</span><br><span class="line">            Scanner sc = new Scanner(System.in);</span><br><span class="line">            while(sc.hasNext())&#123;</span><br><span class="line">                String message = sc.nextLine();</span><br><span class="line">                future.channel().writeAndFlush(message);</span><br><span class="line">            &#125;</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            group.spliterator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerHandler:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.im.netty.server;</span><br><span class="line"></span><br><span class="line">import io.netty.channel.ChannelHandler;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandler;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.util.internal.PlatformDependent;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ConcurrentMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by bruce on 2019/6/10.</span><br><span class="line"> */</span><br><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class ServerHandler implements ChannelInboundHandler &#123;</span><br><span class="line"></span><br><span class="line">    //存放客户端和服务端之间的连接</span><br><span class="line">    private static ConcurrentMap&lt;String,ChannelHandlerContext&gt; channelConcurrentMap = PlatformDependent.newConcurrentHashMap();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRegistered(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelUnregistered(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line">        //获取客户端的ip</span><br><span class="line">        String hostString = ((SocketChannel)channelHandlerContext.channel()).remoteAddress().getHostString();</span><br><span class="line">        System.out.println(hostString + &quot; online&quot;);</span><br><span class="line">        //将客户端和服务端之间的连接存放在concurrentHashMap中</span><br><span class="line">        channelConcurrentMap.put(hostString,channelHandlerContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext channelHandlerContext, Object o) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;ServerHandler channelRead....&quot;);</span><br><span class="line">        //客户端通过Terminal连接后的输入格式为  message@ip ,这个消息接收者ip会收到message消息</span><br><span class="line">        //例如:   你最近还好吗,Bruce@10.1.128.1</span><br><span class="line">        String messageString = o.toString();</span><br><span class="line">        String[] messages = messageString.split(&quot;@&quot;);</span><br><span class="line">        String message = messages[0];</span><br><span class="line">        String targetHost = messages[1];</span><br><span class="line">        System.out.println(channelHandlerContext.channel().remoteAddress()+&quot;-&gt;Server :&quot;+o.toString());</span><br><span class="line">        ChannelHandlerContext targetChannelHandlerContext = channelConcurrentMap.get(targetHost);</span><br><span class="line">        targetChannelHandlerContext.write(channelHandlerContext.channel().remoteAddress() + &quot; say : &quot; + message);</span><br><span class="line">        targetChannelHandlerContext.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext channelHandlerContext, Object o) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelWritabilityChanged(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerAdded(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext channelHandlerContext) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext channelHandlerContext, Throwable throwable) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.im.netty.client;</span><br><span class="line"></span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by bruce on 2019/6/10.</span><br><span class="line"> */</span><br><span class="line">public class ClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Client01Handler Active&quot;);</span><br><span class="line">        //ctx.fireChannelActive();  // 若把这一句注释掉将无法将event传递给下一个ClientHandler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码地址：<a href="https://github.com/bruceChi/nettyIM" target="_blank" rel="noopener">https://github.com/bruceChi/nettyIM</a><br>参考资料：<br>1、<a href="http://tutorials.jenkov.com/java-nio" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio</a><br>2、 UNIX Network Programming<br>3、 <a href="https://www.jianshu.com/p/63a006e5e22d" target="_blank" rel="noopener">https://www.jianshu.com/p/63a006e5e22d</a><br>4、<a href="http://tutorials.jenkov.com/netty" target="_blank" rel="noopener">http://tutorials.jenkov.com/netty</a><br>5、<a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf" target="_blank" rel="noopener">http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf</a><br>6、 <a href="https://www.cnblogs.com/winner-0715/p/8733787.html" target="_blank" rel="noopener">https://www.cnblogs.com/winner-0715/p/8733787.html</a><br>7、 <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/03/浅谈netty/" data-id="cjyvdri8t0000qos6jowiz0lu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈dubbo微服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/03/浅谈dubbo微服务/" class="article-date">
  <time datetime="2019-08-03T03:14:19.613Z" itemprop="datePublished">2019-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/03/浅谈dubbo微服务/">浅谈dubbo微服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="实现一个简单的RPC系统"><a href="#实现一个简单的RPC系统" class="headerlink" title="实现一个简单的RPC系统"></a>实现一个简单的RPC系统</h1><p><img src="https://upload-images.jianshu.io/upload_images/15507353-8284522c66270638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>provider:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.demo.rpc;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2018/4/16.</span><br><span class="line"> */</span><br><span class="line">public class Provider &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //新建一个server socket 端口号为1234，普通的RPC调用可以通过socket来实现 </span><br><span class="line">        ServerSocket server=new ServerSocket(1234);</span><br><span class="line">        //监听socket连接并响应</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            Socket socket=server.accept();</span><br><span class="line">            ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            //获得服务端要调用的类名</span><br><span class="line">            String classname=input.readUTF();</span><br><span class="line">            //获得服务端要调用的方法名称</span><br><span class="line">            String methodName=input.readUTF();</span><br><span class="line">            //获得服务端要调用方法的参数类型</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes=(Class&lt;?&gt;[]) input.readObject();</span><br><span class="line">            //获得服务端要调用方法的每一个参数的值</span><br><span class="line">            Object[] arguments=(Object[]) input.readObject();</span><br><span class="line"></span><br><span class="line">            //创建类</span><br><span class="line">            Class serviceClass=Class.forName(classname);</span><br><span class="line">            //创建对象</span><br><span class="line">            Object object = serviceClass.newInstance();</span><br><span class="line">            //获得该类的对应的方法</span><br><span class="line">            Method method=serviceClass.getMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line">            //该对象调用指定方法</span><br><span class="line">            Object result=method.invoke(object, arguments);</span><br><span class="line"></span><br><span class="line">            ObjectOutputStream output=new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            output.writeObject(result);</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.demo.rpc;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">/**</span><br><span class="line"> * Created by duheng on 2018/4/16.</span><br><span class="line"> */</span><br><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public void doBusiness() throws Exception&#123;</span><br><span class="line">        //设置调用类的路径和要调用的方法</span><br><span class="line">        String classname=&quot;com.dfire.demo.rpc.RPCServiceImpl&quot;;</span><br><span class="line">        String method=&quot;sayHello&quot;;</span><br><span class="line">        Class[] argumentsType=&#123;String.class&#125;;</span><br><span class="line"></span><br><span class="line">        //获取本机计算机名称</span><br><span class="line">        InetAddress inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        String hostName = inetAddress.getHostName().toString();</span><br><span class="line"></span><br><span class="line">        Object[] arguments=&#123;hostName&#125;;</span><br><span class="line"></span><br><span class="line">        //与10.1.134.145主机建立socket连接进行通讯</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;,1234);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream output=new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        //输入数据</span><br><span class="line">        output.writeUTF(classname);</span><br><span class="line">        output.writeUTF(method);</span><br><span class="line">        output.writeObject(argumentsType);</span><br><span class="line">        output.writeObject(arguments);</span><br><span class="line"></span><br><span class="line">        //得到返回数据</span><br><span class="line">        ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</span><br><span class="line">        Object result=input.readObject();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; &quot;+result);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            new Consumer().doBusiness();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入命令查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:1234</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/15507353-d2ca2831efcc14b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上图显示线程16419在监听TCP的通讯，做为RPC的server端<br>下面我们看下我们的dubbo的通讯监听情况：<br>先看服务提供者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:20881</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/15507353-967cca3e97f0f800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>下面为服务消费者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:20880</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/15507353-b055268eec21a80d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>最后边的许多连接表示10.1.134.145连接了多个机器的服务【服务提供者端口为20880】</p>
<p>上面通过两个简单的类Provider和Consumer实现了一个简单的RPC系统，大家应该就能清楚认识到RPC的整个架构和通讯是比较简单的，当然上面的这个RPC系统有很多缺点：</p>
<ul>
<li>BIO，不能支持高并发。</li>
<li>不支持负载均衡</li>
<li>不支持容错机制</li>
<li>不支持SPI扩展</li>
<li>不支持各种序列化</li>
<li>不支持自动注册和发现<br>当然还有其他很多缺点，业界有很多RPC的框架，例如：dubbo，我们下面来讲一下讲。</li>
</ul>
<p>下面是从dubbo官网copy下面的一段话，对dubbo的简单描述：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-c8b22e2d9ef502ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-554acf83e6ca02f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="dubbo的拓扑图"><a href="#dubbo的拓扑图" class="headerlink" title="dubbo的拓扑图"></a>dubbo的拓扑图</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-abb9741897ac4c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15507353-f03d19155de231a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们上面自己实现的RPC系统就缺少Registry和Monitor这两个模块，当然其他模块也很弱</p>
<h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-5cc714e867d0939b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</p>
</li>
<li><p>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</p>
</li>
<li><p>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</p>
</li>
<li><p>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口 为 Cluster, Directory, Router, LoadBalance</p>
</li>
<li><p>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorServiceprotocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</p>
</li>
<li><p>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</p>
</li>
<li><p>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codecserialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool    </p>
<h2 id="调用链："><a href="#调用链：" class="headerlink" title="调用链："></a>调用链：</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-0b007ca9dbfbba08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>##服务提供者暴露一个服务的过程：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-458f410c43c0bfb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="暴露服务时序图"><a href="#暴露服务时序图" class="headerlink" title="暴露服务时序图"></a>暴露服务时序图</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-b230b96fa5477a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>##服务消费者消费一个服务的过程<br><img src="https://upload-images.jianshu.io/upload_images/15507353-e206f75c790c8fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>##引用服务时序<br><img src="https://upload-images.jianshu.io/upload_images/15507353-88b5d37afb703eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="服务提供-Invoker-和服务消费-Invoker"><a href="#服务提供-Invoker-和服务消费-Invoker" class="headerlink" title="服务提供 Invoker 和服务消费 Invoker"></a>服务提供 Invoker 和服务消费 Invoker</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-5bfdb5b4bad5334d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="核心领域模型-Microkernel-Plugin-模式"><a href="#核心领域模型-Microkernel-Plugin-模式" class="headerlink" title="核心领域模型(Microkernel + Plugin 模式)"></a>核心领域模型(Microkernel + Plugin 模式)</h2></li>
<li><p>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</p>
</li>
<li><p>functionalities是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可</p>
<pre><code>执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可
能一个集群实现。</code></pre></li>
<li><p>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</p>
<h2 id="dubbo：-数据传输"><a href="#dubbo：-数据传输" class="headerlink" title="dubbo：// 数据传输"></a>dubbo：// 数据传输</h2><p>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-916318aadea8c3ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>+ Transporter:     mina, netty, grizzy
+ Serialization:    dubbo, hessian2, java, json
+ Dispatcher: all, direct, message, execution, connection
+ ThreadPool: fixed, cached, limited</code></pre><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>对于Dubbo集群中的Provider角色，有IO线程池和业务处理线程池（默认200）两个线程池，所以当业务的并发比较高，或者某些业务处理变慢，业务线程池就很容易被“打满”，抛出“RejectedExecutionException: Thread pool is EXHAUSTED! ”异常。</p>
</li>
</ul>
<ol>
<li>all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。 </li>
<li>direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li>
<li>message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在IO线程上执行。</li>
<li>execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li>connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:provider version=&quot;1.0&quot; delay=&quot;-5000&quot; timeout=&quot;5000&quot; dispatcher=&quot;all&quot; threads=&quot;400&quot; loadbalance=&quot;leastactive&quot; actives=&quot;400&quot; /&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h3><ol>
<li><p>fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)。</p>
</li>
<li><p>cached 缓存线程池，空闲一分钟自动删除，需要时重建。</p>
</li>
<li><p>limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</p>
</li>
<li><p>eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时,优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超<br>过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)。</p>
</li>
</ol>
<h2 id="zookeeper-注册中心"><a href="#zookeeper-注册中心" class="headerlink" title="zookeeper 注册中心"></a>zookeeper 注册中心</h2><p>Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-1b3df1f850cad941.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="流程说明："><a href="#流程说明：" class="headerlink" title="流程说明："></a>流程说明：</h6><ol>
<li>服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址。</li>
<li>服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址。</li>
<li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。<h2 id="Fault-Tolerance-容错"><a href="#Fault-Tolerance-容错" class="headerlink" title="Fault Tolerance 容错"></a>Fault Tolerance 容错</h2></li>
<li>Failover – FailoverClusterInvoker<pre><code>失败自动切换，尝试其他服务器。 (默认的方案)</code></pre></li>
<li>Failfast – FailfastClusterInvoker<pre><code>失败立即抛出异常,。通常用于非幂等性的写操作，比如新增记录。</code></pre></li>
<li>Failsafe – FailsafeClusterInvoker<pre><code>失败忽略异常。通常用于写入审计日志等操作。</code></pre></li>
<li>Failback – FailbackClusterInvoker<pre><code>失败自动恢复，记录日志并定时重试。 通常用于消息通知操作。</code></pre></li>
<li>Forking – ForkingClusterInvoker<pre><code>并行调用多个服务，一个成功立即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</code></pre></li>
<li>Broadcast – BroadcastClusterInvoker<pre><code>广播调用所有提供者，任意一个报错则报错</code></pre></li>
</ol>
<h2 id="Load-Balancing-负载均衡"><a href="#Load-Balancing-负载均衡" class="headerlink" title="Load Balancing 负载均衡"></a>Load Balancing 负载均衡</h2><ol>
<li><p>random (随机，按权重设置随机概率)  默认的策略</p>
<ol start="2">
<li><p>round-robin (轮循，按公约后的权重设置轮循比率)<br> 存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，<br> 当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 </p>
</li>
<li><p>least-active (最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。) 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大，不支持权重。 【线上用得比较多，注意dubbo低版本有bug】</p>
</li>
<li><p>consistent-hash(一致性Hash，相同参数的请求总是发到同一提供者)<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动，会导致压力分摊不均。</p>
</li>
<li><p>支持扩展 </p>
<pre><code>需要实现AbstractLoadBalance接口</code></pre></li>
</ol>
</li>
</ol>
<h2 id="SPI扩展实现"><a href="#SPI扩展实现" class="headerlink" title="SPI扩展实现"></a>SPI扩展实现</h2><p>一、调用拦截扩展<br>扩展说明：服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。dubbo层的限流和熔断可以用这个filter扩展来实现。</p>
<p>约定：</p>
<ul>
<li>用户自定义 filter 默认在内置 filter 之后。</li>
<li>特殊值 default，表示缺省扩展点插入的位置。比如：filter=“xxx,default,yyy”，表示 xxx 在缺省 filter 之前，yyy 在缺省 filter 之后。</li>
<li>特殊符号 -，表示剔除。比如：filter=“-foo1”，剔除添加缺省扩展点 foo1。比如：filter=“-default”，剔除添加所有缺省扩展点。</li>
<li>provider 和 service 同时配置的 filter 时，累加所有 filter，而不是覆盖。比如：&lt;dubbo:provider filter=”xxx,yyy”/&gt; 和 &lt;dubbo:service filter=”aaa,bbb” /&gt;，则 xxx,yyy,aaa,bbb 均会生效。如果要覆盖，需配置：&lt;dubbo:service filter=”-xxx,-yyy,aaa,bbb” /&gt;</li>
</ul>
<p>接口com.alibaba.dubbo.rpc.Filter<br>扩展配置<br>&lt;dubbo:reference filter= “xxx,yyy” /&gt;   <!-- 消费方调用过程拦截 --><br>&lt;dubbo:consumer filter= “xxx,yyy” /&gt;   <!-- 消费方调用过程缺省拦截器，将拦截所有reference --><br>&lt;dubbo:service filter= “xxx,yyy” /&gt;       <!-- 提供方调用过程拦截 --><br>&lt;dubbo:provider filter= “xxx,yyy” /&gt;      <!-- 提供方调用过程缺省拦截器，将拦截所有service --><br>已知扩展<br>com.alibaba.dubbo.rpc.filter.EchoFilter<br>com.alibaba.dubbo.rpc.filter.GenericFilter<br>com.alibaba.dubbo.rpc.filter.GenericImplFilter<br>com.alibaba.dubbo.rpc.filter.TokenFilter<br>com.alibaba.dubbo.rpc.filter.AccessLogFilter<br>com.alibaba.dubbo.rpc.filter.CountFilter<br>com.alibaba.dubbo.rpc.filter.ActiveLimitFilter<br>com.alibaba.dubbo.rpc.filter.ClassLoaderFilter<br>com.alibaba.dubbo.rpc.filter.ContextFilter<br>com.alibaba.dubbo.rpc.filter.ConsumerContextFilter<br>com.alibaba.dubbo.rpc.filter.ExceptionFilter<br>com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter<br>com.alibaba.dubbo.rpc.filter.DeprecatedFilter</p>
<p>总结得比较简单，摘自我的培训课件，适合根据这个文章来做分享，欢迎大家一起交流。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/03/浅谈dubbo微服务/" data-id="cjyuyshdf0000ifs6rvk20lvp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/深入理解volatile/" class="article-date">
  <time datetime="2019-07-26T07:48:29.727Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/深入理解volatile/">深入理解volatile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#JMM Java 内存模型<br>Java的内存模型指定了Java虚拟机如何与计算机的内存进行工作<br><img src="https://upload-images.jianshu.io/upload_images/15507353-f6fa34679930e9c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系，具体如下：<br>1、共享变量存储在主内存中，每个线程都可以访问。<br>2、每个线程都有私有的工作内存。<br>3、工作内存只存储该线程对共享变量的副本。<br>4、线程不能直接操作主内存，只有先操作了工作内存之后才能写入内存。<br>      假设主内存的共享变量为0，线程1和线程2分享拥有共享变量X的副本，假设线程1此时将工作内存中的X修改为1，同时刷新到主内存中，当线程2想要去使用副本X的时候，就会发现该变量已经失效了，必须到主内存中再次获取然后存入自己的工作内容中，这一点和CPU与CPU Cache之间的关系非常类似。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-d1850faa3ea16741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当同一个数据被分别存储到了计算机的各个内存区域时，就会导致多个线程在各自的工作内存中看到的可能不一样。后面会讲到Java语言中如何保证不通线程对某个共享变量的可见性。</p>
<p>#多线程可见性例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/17.</span><br><span class="line"> */</span><br><span class="line">public class VolatileFoo &#123;</span><br><span class="line"></span><br><span class="line">    //init_value 的最大值</span><br><span class="line">    final static  int MAX  = 5 ;</span><br><span class="line"></span><br><span class="line">    //init_value 的初始值</span><br><span class="line">    static int init_value = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //启动一个Reader线程 ,当发现local_value 和 init_value 不同时,则输出 init_value 被修改的信息</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int localValue = init_value;</span><br><span class="line">                while (localValue &lt; MAX)&#123;</span><br><span class="line">                    if(init_value != localValue)&#123;</span><br><span class="line">                        System.out.printf(&quot;The init_value is updated to [%d]\n&quot;,init_value);</span><br><span class="line">                        //对localValue 进行重新赋值</span><br><span class="line">                        localValue = init_value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;Reader&quot;).start();</span><br><span class="line"></span><br><span class="line">        //启动Updater线程,主要用于对init_value的修改,当local_value&gt;=5的时候则退出生命周期</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int localValue = init_value;</span><br><span class="line">                while(localValue &lt; MAX)&#123;</span><br><span class="line">                    //修改init_value</span><br><span class="line">                    System.out.printf(&quot;The init_value will be changed to [%d]\n&quot;,++localValue);</span><br><span class="line">                    init_value = localValue;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //短暂休眠 目的是为了使Reader线程来得及输出变化内容</span><br><span class="line">                        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家先猜一下，运行结果是怎么样的？可能会大失所望<br>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/bin/java -Dvisualvm.id=83453442187216 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -Didea.launcher.port=7534 &quot;-Didea.launcher.bin.path=/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/tools.jar:/Users/bruce/2dfire/workspace/jvmstudy/target/classes:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain com.just.study.jvm.concurrent.VolatileFoo</span><br><span class="line">The init_value will be changed to [1]</span><br><span class="line">The init_value will be changed to [2]</span><br><span class="line">The init_value will be changed to [3]</span><br><span class="line">The init_value will be changed to [4]</span><br><span class="line">The init_value will be changed to [5]</span><br></pre></td></tr></table></figure>

<p>通过控制台的输出我们发现：Reader线程压根就没有感知到init_value的变化、并且进入了死循环线程没有退出<br>我们对代码做一个调整，将init_value变量设置为volatile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//init_value 的初始值</span><br><span class="line">static volatile int init_value = 0;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/bin/java -Dvisualvm.id=83688650193139 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -Didea.launcher.port=7535 &quot;-Didea.launcher.bin.path=/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/tools.jar:/Users/bruce/2dfire/workspace/jvmstudy/target/classes:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain com.just.study.jvm.concurrent.VolatileFoo</span><br><span class="line">The init_value will be changed to [1]</span><br><span class="line">The init_value is updated to [1]</span><br><span class="line">The init_value will be changed to [2]</span><br><span class="line">The init_value is updated to [2]</span><br><span class="line">The init_value will be changed to [3]</span><br><span class="line">The init_value is updated to [3]</span><br><span class="line">The init_value will be changed to [4]</span><br><span class="line">The init_value is updated to [4]</span><br><span class="line">The init_value will be changed to [5]</span><br><span class="line">The init_value is updated to [5]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>为啥会发生这样的改变、后面会慢慢讲到、这里是因为volatile可以保证多线程环境下的可见性、还有volatile的变量是先被写后再被读（后续会讲到）。</p>
<p>#CPU缓存模型和缓存一致性<br>CPU在速度上的发展要快与内存在速度上的发展，由于两边速度严重的不等，所以为了增加吞吐量，缩小CPU和内存的速度差，建立了CPU Cache模型，就是大家所熟知的L1、L2、L3 CPU高速缓存。CPU Cache又由很多个Cache Line构成，Cache Line可以认为是CPU Cache中最小的缓存单元。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-1c1459c4595a142e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15507353-c559c153d83f7a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>程序运行过程中，会将运算锁需要的数据从内存复制一份到CPU Cache中，然后进行读取和写入，当运算结束之后，在将CPU Cache中的最新数据刷新到内存中，这样通过CPU Cache在中间做交互，提高了CPU的吞吐能力。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-5ec72c9d6d40d6fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>CPU Cache虽然提高了CPU的吞吐能力，同时也带来了一个问题：缓存不一致的问题，比如i++这个操作，运行的过程如下；<br>1、读取主内存的i到CPU Cache中。<br>2、对i进行加一的操作。<br>3、将结果写回到CPU Cache中。<br>4、将数据刷新到主内存中。<br>i++在单线程的情况下不会有任何问题，但在多线程的情况下就会有问题，每个线程都有自己的工作内存（对于于CPU的Cache），变量i会在多个线程的本地内存中都存在一个副本。如果同时有两个线程执行i++操作，假设i的初始值为0，每一个线程都从主内存获取i的值存入CPU Cache中，然后经过计算在写入主内存中，很有可能i在经过了两次自增之后结果还是1，这就是典型的缓存不一致问题。<br>主要有两种解决方法：<br>1、通过总线加锁。<br>2、通过缓存一致性协议。<br>第一种是悲观的实现方式，CPU和其他组件的通信都是通过总线来进行，会有阻塞，效率低下。</p>
<p>第二种：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-5d538923e3a0d23e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>在缓存一致性中最为出名的是Intel的MESI协议，MESI协议保证了每一个缓存汇中使用的是共享变量副本都是一致的，大概意思就是当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，也就是说在其他的CPU Cache中也存在一个副本，那么进行如下操作：<br>1、读取操作，不做任何处理，只是将Cache中的数据读取到寄存器。<br>2、写入操作，发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU在进行该变量读取的时候不得不到主内存中再次获取。</p>
<p>#并发编程三大特性：原子性、可见性、有序性</p>
<p>##原子性<br>原子性是值指在一次的操作或者多次操作中，要么所有的操作全部得到执行，要么所有的操作都不执行。i++ 是由三个原子操作组成get i, i+1 ,set i = x，但是i++就不是原子性操作。volatile不保证原子性，synchronized保证原子性，JUC的原子性类型保证原子性，例如：AtomicInteger，通过volatile和CAS来实现。</p>
<p>##可见性<br>可见性是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的新值。例如上面我们的例子Reader线程会将init_value从内存缓存到CPU Cache中，也就是从主内存缓存到线程的工作内存中，Updater线程对init_value的修改对Reader线程是不可见的。</p>
<p>##有序性<br>有序性就是程序代码在执行过程中的先后顺序，Java在编译器以及运行期的优化，会产生指令重排序，导致了代码的执行顺序不一定是编写代码时的顺序，指令重排序是在不影响运行结果的情况下进行重排序，对于单线程来说指令重排序不会有问题。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 0;</span><br><span class="line">x++;</span><br><span class="line">y=20;</span><br></pre></td></tr></table></figure>

<p>但是在多线程的情况下，如果有序性得不到保证，那么很有可能就会出现问题，例如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean initialized = false;</span><br><span class="line">private Context context = null;</span><br><span class="line">public Context load()&#123;</span><br><span class="line">     if(!initialized)&#123;</span><br><span class="line">        context = loadContext();</span><br><span class="line">        initialized = true;</span><br><span class="line">     &#125;</span><br><span class="line">     return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单线程情况，这段代码重排序，录入把   initialized = true;放到   context = loadContext();调换位置，不会有问题，但是如果多线程情况下第二个线程在调用load方法后可能会得到一个null。</p>
<p>#JMM如何保证原子性、可见性、有序性<br>JVM采用内存模型的机制来屏蔽哥哥平台与操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果。比如C语言中的整型变量，在某些平台下占用了两个字节的内存，在某些平台下则占用了四个字节的内存，Java则在任何平台下，int类型就是四个字节，这就是一直内存访问效果。</p>
<p>##JMM与原子性<br>在Java语言中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的。<br>1、x=10 原子操作<br>2、y=x  非原子操作【两个原子操作合在一起就不是原子操作】<br>     1）执行线程从主内存中读取x的值（如果在工作内存就直接从工作内存获取）<br>     2）在执行线程的工作内存中修改y的值为x,然后将y的值写入主内存之中。<br>3、y++ 自增操作 不是原子的，因为包含三个原子操作：<br>    1)执行线程从主内存中读取y的值（如果y已存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存中。<br>    2）在执行线程工作内存中为y执行加1的操作。<br>    3）将y的值写入主内存。<br>结论：<br>        a、多个原子性操作在一起就不在是原子性操作了。<br>        b、简单的读取和赋值操作是原子性操作，将一个变量赋给另外一个变量的操作不是原子性操作。<br>       c、Java内存模型只保证了基本读取和赋值的原子性操作，其他的均不保证，如果先更要使得某些代码片段具备原子性，需使用关键字synchronized,或者JUC中的lock。原子封装类：AtomicInteger等。<br>总结：volatile不具备保证原子性的语义</p>
<p>#JMM与可见性<br>在多线程的环境下，如果某个线程首次读取共享变量，首先到主内存获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后在刷新至主内存中。但是什么时候最新的值会被刷新至主内存是不太确定的，这就解释了为什么没有加volatile关键字的时候VolatileFoo中的Reader线程始终无法获取到init_value最新的变化。<br>Java提供三种方式来保证可见性：<br>1）使用关键字volatile，共享资源的读操作直接在内存中进行。写操作是先写工作内存，然后立刻刷新到主内存中。<br>2）synchronized保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中。<br>3）通过JUC提供的显示锁lock也能够保证可见性，Lock的lock防范能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放之前会将对变量的修改刷新到主内存当中。</p>
<p>注：1、JVM禁用JIT即时编译器的后多线程环境下共享变量也具有可见性<br>例如下面代码,如果添加JVM参数 -server -Djava.compiler=NONE  或者 -Xint 多线程环境下flag共享变量就具有可见性<br>       2、System.out.print() 输出流会加锁，也具有可见性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/26.</span><br><span class="line"> */</span><br><span class="line">public class Zuo &#123;</span><br><span class="line"></span><br><span class="line">    private static boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        flag = false;</span><br><span class="line">        System.out.println(&quot;flag set to false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void print() &#123;</span><br><span class="line">        while (flag) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#JMM与有序性<br>在Java内存模型中，允许编译器和处理器对指令进行重排序，在单线程的情况下，重排序不会有问题，但是多线程的情况下，会影响程序的正确运行。<br>Java提供了三种保证有序性的方式：</p>
<ul>
<li>使用关键字volatile。</li>
<li>synchronized关键字。</li>
<li>使用显示Lock。<br>后两者是采用同步。</li>
</ul>
<p>Java内存的天生有一些有序性规则-Happens-before原则。如果两个操作无法从happens-before推导出来，那么他们就无法保证有序性。</p>
<ul>
<li>程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后，虚拟机还是会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。</li>
<li>锁定规则：一个unlock操作要先行发生在对同一个锁的lock操作。</li>
<li>volatile变量规则：对一个变量的写操作要早与对这个变量之后的读操作。意思是一个变量volatile,一个线程对它进行读，一个线程对它进行写，写操作一定是先行发生于读操作。</li>
<li>传递规则：如果操作A先于操作B，而操作B又先于操作C，则A先于操作C。</li>
<li>线程启动规则：Thread对象的start()方法先行于线程的任何动作。</li>
<li>线程中断规则：对线程执行interrupt()方法肯定要优先于捕捉到中断信号，意<br> 思是如果线程收到了中断信号，那么在此之前势必要有interrupt()。</li>
<li>线程的终结规则：线程中所有的操作都要先行发生于线程的终止检测，意识是线程的任务执行，逻辑单元执行肯定要发生于线程死亡之前。</li>
<li>对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前，意思是先生后死。<br>总结：volatile关键字保证有序性<br>#volatile关键字深入解析<br>volatile具有两个语义：</li>
<li>保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修改的变量，另外一个线程会立即看到最新的值。</li>
<li>禁止对指令进行重排序操作。<br>（1）理解volatile保证可见性：<pre><code>VolatileFoo例子，Updater线程对init_value变量的每一次更改都会使得Reader线程能够看到(happens-before规则中，第三条volatile变量规则：对一个变量的写操作要早于对这个变量之后的读操作)，步骤：</code></pre></li>
</ul>
<ol>
<li>Reader线程从主内存获取init_value的值为0，并且将其缓存到本地工作内存中。</li>
<li>Updater线程将init_value的值在本地工作内存中修改为1，然后立即刷新至主内存中。</li>
<li>Reader线程在本地工作内存中的init_value失效。（反映到硬件上就是CPU Cache 的 Cache Line失效）</li>
<li>由于Reader线程的工作内存中的init_value失效，因此需要从主内存中从新读取init_value的值。<br>（2）理解volatile保证有序性<br>volatile关键字对有序性的保证比较粗暴，直接静止JVM和处理器对volatile关键字修改的指令重排序，但是对volatile前后无依赖关系的指令则可以随便怎么排序。<br>（3）理解volatile不保证原子性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/21.</span><br><span class="line"> * //没次的运行结果不一样,具体原因是 i++ 不是一个原子操作,i++操作分三步:</span><br><span class="line"> *    1、从主内存中获取i的值,然后魂村至线程工作内存中。</span><br><span class="line"> *    2、在线程工作内存中为进行加1的操作。</span><br><span class="line"> *    3、将i的最新值写入主内存中。</span><br><span class="line"> *    上面三个操作单独的每一个操作都是原子性操作,但是合起来就不是原子性操作了。</span><br><span class="line"> */</span><br><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    //使用volatile修改共享资源i</span><br><span class="line">    private static volatile  int i = 0;</span><br><span class="line">    //private static AtomicInteger i = new AtomicInteger(0);</span><br><span class="line">    //10个线程</span><br><span class="line">    private static final CountDownLatch latch  = new CountDownLatch(10);</span><br><span class="line"></span><br><span class="line">    private static void inc()&#123;</span><br><span class="line">          i++;</span><br><span class="line">        //i.addAndGet(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i&lt; 10;i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line"></span><br><span class="line">                    for (int x = 0; x &lt; 1000; x++)&#123;</span><br><span class="line">                        inc();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //使计算器减1</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //等待所有的线程完成工作</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/bin/java -Dvisualvm.id=89098433865570 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -Didea.launcher.port=7533 &quot;-Didea.launcher.bin.path=/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/tools.jar:/Users/bruce/2dfire/workspace/jvmstudy/target/classes:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain com.just.study.jvm.concurrent.VolatileTest</span><br><span class="line">9656</span><br></pre></td></tr></table></figure>

<p>上面代码创建了10个线程，每个线程执行1000次对共享变量i的自增操作，但是最终结果可能不是10000，因为这段代码的 i++ 操作其实是3个原子操作合起来的，3个原子操作合起来就不是原子操作了。</p>
<p>#volatile的原理和实现机制<br>下面为OpenJDK下的unsafe.cpp源码，会发现被volatile装饰的变量存在于一个”lock”的前缀，源码如下：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-90a36fe1093a17f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>#volatile的使用场景<br>虽然volatile有部分synchronized关键字的语义，但是volatile不可能完全替代synchronized关键字，因为volatile关键字不具备原子性操作语义，我们在使用volatile关键字的时候也是充分利用它的可见性以及有序性（防止重排序）特点。</p>
<ol>
<li>开关控制-利用可见性的特点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/25.</span><br><span class="line"> */</span><br><span class="line">public class ThreadCloseable extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    //volatile 关键字保证了started线程的可见性</span><br><span class="line">    private volatile boolean started = true;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        while (started) &#123;</span><br><span class="line">            //do work</span><br><span class="line">            System.out.println(&quot;I am working&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        this.started = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>2.状态标记顺序性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//阻止重排序</span><br><span class="line">private volatile boolean initialized = false;</span><br><span class="line">private Context context;</span><br><span class="line">public Context load() &#123;</span><br><span class="line">    if(!initialized)&#123;</span><br><span class="line">        context = loadContext();</span><br><span class="line">        //如果这里的initialized变量不是volatile的，那么指令重排序后</span><br><span class="line">        //假设 initialized = true;重排到context = loadContext();之前多线程访问情况下就会出现问题</span><br><span class="line">        initialized = true;  </span><br><span class="line">    &#125;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.单例模式的double-check也利用了volatile的有序性</p>
<p>#volatile和synchronized对比<br>（1）使用上的区别</p>
<ul>
<li>volatile关键字只能用于修改实例变量或者类变量，不能用于修改方法以及方法参数和局部变量、常量等。</li>
<li>synchronized关键字不能用于对变量的修饰，只能用于修饰方法或者语句块。</li>
<li>volatile修饰的变量可以为null,synchronized关键字同步块的monitor对象不能为null。<br>(2)对原子性的保证</li>
<li>volatile无法保证原子性。</li>
<li>由于synchronized是一种排他的机制，因此被synchronized关键字修饰的同步代码是无法被中途打断的，因此其能够保证代码的原子性。<br>(3)对可见性的保证</li>
<li>两者均可以保证资源在多线程间的可见性，但是实现机制完全不同。</li>
<li>synchronized借助于JVM指令monitor enter 和 monitor exit对通过排他的方式使得同步代码串行化，在monitor exit时所有共享资源都会被刷新到主内存中。</li>
<li>相比较于synchronized关键字volatile使用机器指令(偏硬件)“lock;”的方式迫使其他线程工作内存中的数据失效，需要到主内存中进行再次加载。<br>（4）对有序性的保证</li>
<li>volatile关键字禁止JVM编译器以及处理器对其进行重排序。</li>
<li>虽然synchronized关键字所修饰的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修饰的代码中代码指令也会发生指令重排序的情况，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(this)&#123;</span><br><span class="line">     int x = 10;</span><br><span class="line">     int y =20;</span><br><span class="line">     x++;</span><br><span class="line">     y = y+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>x和y谁先定义谁最先进行运算，对结果没有影响。达到了最终的输出结果和代码编写顺序的一致性。<br>（5）其他</p>
<ul>
<li>volatile不会使线程陷入阻塞。</li>
<li>synchronized会使线程进入阻塞状态。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/26/深入理解volatile/" data-id="cjytpmaxu0000uas6dza7yjan" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/03/浅谈netty/">浅谈netty</a>
          </li>
        
          <li>
            <a href="/2019/08/03/浅谈dubbo微服务/">浅谈dubbo微服务</a>
          </li>
        
          <li>
            <a href="/2019/07/26/深入理解volatile/">深入理解volatile</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 池元嘉<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>