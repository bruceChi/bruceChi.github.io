<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>梦想成为一个码农</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="梦想成为一个码农">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="梦想成为一个码农">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="梦想成为一个码农">
  
    <link rel="alternate" href="/atom.xml" title="梦想成为一个码农" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">梦想成为一个码农</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-浅谈dubbo微服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/03/浅谈dubbo微服务/" class="article-date">
  <time datetime="2019-08-03T03:14:19.613Z" itemprop="datePublished">2019-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/03/浅谈dubbo微服务/">浅谈dubbo微服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="实现一个简单的RPC系统"><a href="#实现一个简单的RPC系统" class="headerlink" title="实现一个简单的RPC系统"></a>实现一个简单的RPC系统</h1><p><img src="https://upload-images.jianshu.io/upload_images/15507353-8284522c66270638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>provider:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.demo.rpc;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2018/4/16.</span><br><span class="line"> */</span><br><span class="line">public class Provider &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //新建一个server socket 端口号为1234，普通的RPC调用可以通过socket来实现 </span><br><span class="line">        ServerSocket server=new ServerSocket(1234);</span><br><span class="line">        //监听socket连接并响应</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            Socket socket=server.accept();</span><br><span class="line">            ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            //获得服务端要调用的类名</span><br><span class="line">            String classname=input.readUTF();</span><br><span class="line">            //获得服务端要调用的方法名称</span><br><span class="line">            String methodName=input.readUTF();</span><br><span class="line">            //获得服务端要调用方法的参数类型</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes=(Class&lt;?&gt;[]) input.readObject();</span><br><span class="line">            //获得服务端要调用方法的每一个参数的值</span><br><span class="line">            Object[] arguments=(Object[]) input.readObject();</span><br><span class="line"></span><br><span class="line">            //创建类</span><br><span class="line">            Class serviceClass=Class.forName(classname);</span><br><span class="line">            //创建对象</span><br><span class="line">            Object object = serviceClass.newInstance();</span><br><span class="line">            //获得该类的对应的方法</span><br><span class="line">            Method method=serviceClass.getMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line">            //该对象调用指定方法</span><br><span class="line">            Object result=method.invoke(object, arguments);</span><br><span class="line"></span><br><span class="line">            ObjectOutputStream output=new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            output.writeObject(result);</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.yuanjia.demo.rpc;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">/**</span><br><span class="line"> * Created by duheng on 2018/4/16.</span><br><span class="line"> */</span><br><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public void doBusiness() throws Exception&#123;</span><br><span class="line">        //设置调用类的路径和要调用的方法</span><br><span class="line">        String classname=&quot;com.dfire.demo.rpc.RPCServiceImpl&quot;;</span><br><span class="line">        String method=&quot;sayHello&quot;;</span><br><span class="line">        Class[] argumentsType=&#123;String.class&#125;;</span><br><span class="line"></span><br><span class="line">        //获取本机计算机名称</span><br><span class="line">        InetAddress inetAddress = InetAddress.getLocalHost();</span><br><span class="line">        String hostName = inetAddress.getHostName().toString();</span><br><span class="line"></span><br><span class="line">        Object[] arguments=&#123;hostName&#125;;</span><br><span class="line"></span><br><span class="line">        //与10.1.134.145主机建立socket连接进行通讯</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;,1234);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream output=new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        //输入数据</span><br><span class="line">        output.writeUTF(classname);</span><br><span class="line">        output.writeUTF(method);</span><br><span class="line">        output.writeObject(argumentsType);</span><br><span class="line">        output.writeObject(arguments);</span><br><span class="line"></span><br><span class="line">        //得到返回数据</span><br><span class="line">        ObjectInputStream input=new ObjectInputStream(socket.getInputStream());</span><br><span class="line">        Object result=input.readObject();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; &quot;+result);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            new Consumer().doBusiness();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入命令查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:1234</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/15507353-d2ca2831efcc14b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上图显示线程16419在监听TCP的通讯，做为RPC的server端<br>下面我们看下我们的dubbo的通讯监听情况：<br>先看服务提供者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:20881</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/15507353-967cca3e97f0f800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>下面为服务消费者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:20880</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/15507353-b055268eec21a80d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>最后边的许多连接表示10.1.134.145连接了多个机器的服务【服务提供者端口为20880】</p>
<p>上面通过两个简单的类Provider和Consumer实现了一个简单的RPC系统，大家应该就能清楚认识到RPC的整个架构和通讯是比较简单的，当然上面的这个RPC系统有很多缺点：</p>
<ul>
<li>BIO，不能支持高并发。</li>
<li>不支持负载均衡</li>
<li>不支持容错机制</li>
<li>不支持SPI扩展</li>
<li>不支持各种序列化</li>
<li>不支持自动注册和发现<br>当然还有其他很多缺点，业界有很多RPC的框架，例如：dubbo，我们下面来讲一下讲。</li>
</ul>
<p>下面是从dubbo官网copy下面的一段话，对dubbo的简单描述：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-c8b22e2d9ef502ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/15507353-554acf83e6ca02f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="dubbo的拓扑图"><a href="#dubbo的拓扑图" class="headerlink" title="dubbo的拓扑图"></a>dubbo的拓扑图</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-abb9741897ac4c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15507353-f03d19155de231a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们上面自己实现的RPC系统就缺少Registry和Monitor这两个模块，当然其他模块也很弱</p>
<h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-5cc714e867d0939b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</p>
</li>
<li><p>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</p>
</li>
<li><p>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</p>
</li>
<li><p>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口 为 Cluster, Directory, Router, LoadBalance</p>
</li>
<li><p>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorServiceprotocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</p>
</li>
<li><p>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</p>
</li>
<li><p>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codecserialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool    </p>
<h2 id="调用链："><a href="#调用链：" class="headerlink" title="调用链："></a>调用链：</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-0b007ca9dbfbba08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>##服务提供者暴露一个服务的过程：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-458f410c43c0bfb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="暴露服务时序图"><a href="#暴露服务时序图" class="headerlink" title="暴露服务时序图"></a>暴露服务时序图</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-b230b96fa5477a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>##服务消费者消费一个服务的过程<br><img src="https://upload-images.jianshu.io/upload_images/15507353-e206f75c790c8fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>##引用服务时序<br><img src="https://upload-images.jianshu.io/upload_images/15507353-88b5d37afb703eb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="服务提供-Invoker-和服务消费-Invoker"><a href="#服务提供-Invoker-和服务消费-Invoker" class="headerlink" title="服务提供 Invoker 和服务消费 Invoker"></a>服务提供 Invoker 和服务消费 Invoker</h2><p><img src="https://upload-images.jianshu.io/upload_images/15507353-5bfdb5b4bad5334d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="核心领域模型-Microkernel-Plugin-模式"><a href="#核心领域模型-Microkernel-Plugin-模式" class="headerlink" title="核心领域模型(Microkernel + Plugin 模式)"></a>核心领域模型(Microkernel + Plugin 模式)</h2></li>
<li><p>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</p>
</li>
<li><p>functionalities是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可</p>
<pre><code>执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可
能一个集群实现。</code></pre></li>
<li><p>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</p>
<h2 id="dubbo：-数据传输"><a href="#dubbo：-数据传输" class="headerlink" title="dubbo：// 数据传输"></a>dubbo：// 数据传输</h2><p>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-916318aadea8c3ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<pre><code>+ Transporter:     mina, netty, grizzy
+ Serialization:    dubbo, hessian2, java, json
+ Dispatcher: all, direct, message, execution, connection
+ ThreadPool: fixed, cached, limited</code></pre><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>对于Dubbo集群中的Provider角色，有IO线程池和业务处理线程池（默认200）两个线程池，所以当业务的并发比较高，或者某些业务处理变慢，业务线程池就很容易被“打满”，抛出“RejectedExecutionException: Thread pool is EXHAUSTED! ”异常。</p>
</li>
</ul>
<ol>
<li>all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。 </li>
<li>direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li>
<li>message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在IO线程上执行。</li>
<li>execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>
<li>connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:provider version=&quot;1.0&quot; delay=&quot;-5000&quot; timeout=&quot;5000&quot; dispatcher=&quot;all&quot; threads=&quot;400&quot; loadbalance=&quot;leastactive&quot; actives=&quot;400&quot; /&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h3><ol>
<li><p>fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)。</p>
</li>
<li><p>cached 缓存线程池，空闲一分钟自动删除，需要时重建。</p>
</li>
<li><p>limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</p>
</li>
<li><p>eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时,优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超<br>过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)。</p>
</li>
</ol>
<h2 id="zookeeper-注册中心"><a href="#zookeeper-注册中心" class="headerlink" title="zookeeper 注册中心"></a>zookeeper 注册中心</h2><p>Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-1b3df1f850cad941.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="流程说明："><a href="#流程说明：" class="headerlink" title="流程说明："></a>流程说明：</h6><ol>
<li>服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址。</li>
<li>服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址。</li>
<li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。<h2 id="Fault-Tolerance-容错"><a href="#Fault-Tolerance-容错" class="headerlink" title="Fault Tolerance 容错"></a>Fault Tolerance 容错</h2></li>
<li>Failover – FailoverClusterInvoker<pre><code>失败自动切换，尝试其他服务器。 (默认的方案)</code></pre></li>
<li>Failfast – FailfastClusterInvoker<pre><code>失败立即抛出异常,。通常用于非幂等性的写操作，比如新增记录。</code></pre></li>
<li>Failsafe – FailsafeClusterInvoker<pre><code>失败忽略异常。通常用于写入审计日志等操作。</code></pre></li>
<li>Failback – FailbackClusterInvoker<pre><code>失败自动恢复，记录日志并定时重试。 通常用于消息通知操作。</code></pre></li>
<li>Forking – ForkingClusterInvoker<pre><code>并行调用多个服务，一个成功立即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</code></pre></li>
<li>Broadcast – BroadcastClusterInvoker<pre><code>广播调用所有提供者，任意一个报错则报错</code></pre></li>
</ol>
<h2 id="Load-Balancing-负载均衡"><a href="#Load-Balancing-负载均衡" class="headerlink" title="Load Balancing 负载均衡"></a>Load Balancing 负载均衡</h2><ol>
<li><p>random (随机，按权重设置随机概率)  默认的策略</p>
<ol start="2">
<li><p>round-robin (轮循，按公约后的权重设置轮循比率)<br> 存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，<br> 当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 </p>
</li>
<li><p>least-active (最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。) 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大，不支持权重。 【线上用得比较多，注意dubbo低版本有bug】</p>
</li>
<li><p>consistent-hash(一致性Hash，相同参数的请求总是发到同一提供者)<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动，会导致压力分摊不均。</p>
</li>
<li><p>支持扩展 </p>
<pre><code>需要实现AbstractLoadBalance接口</code></pre></li>
</ol>
</li>
</ol>
<h2 id="SPI扩展实现"><a href="#SPI扩展实现" class="headerlink" title="SPI扩展实现"></a>SPI扩展实现</h2><p>一、调用拦截扩展<br>扩展说明：服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。dubbo层的限流和熔断可以用这个filter扩展来实现。</p>
<p>约定：</p>
<ul>
<li>用户自定义 filter 默认在内置 filter 之后。</li>
<li>特殊值 default，表示缺省扩展点插入的位置。比如：filter=“xxx,default,yyy”，表示 xxx 在缺省 filter 之前，yyy 在缺省 filter 之后。</li>
<li>特殊符号 -，表示剔除。比如：filter=“-foo1”，剔除添加缺省扩展点 foo1。比如：filter=“-default”，剔除添加所有缺省扩展点。</li>
<li>provider 和 service 同时配置的 filter 时，累加所有 filter，而不是覆盖。比如：&lt;dubbo:provider filter=”xxx,yyy”/&gt; 和 &lt;dubbo:service filter=”aaa,bbb” /&gt;，则 xxx,yyy,aaa,bbb 均会生效。如果要覆盖，需配置：&lt;dubbo:service filter=”-xxx,-yyy,aaa,bbb” /&gt;</li>
</ul>
<p>接口com.alibaba.dubbo.rpc.Filter<br>扩展配置<br>&lt;dubbo:reference filter= “xxx,yyy” /&gt;   <!-- 消费方调用过程拦截 --><br>&lt;dubbo:consumer filter= “xxx,yyy” /&gt;   <!-- 消费方调用过程缺省拦截器，将拦截所有reference --><br>&lt;dubbo:service filter= “xxx,yyy” /&gt;       <!-- 提供方调用过程拦截 --><br>&lt;dubbo:provider filter= “xxx,yyy” /&gt;      <!-- 提供方调用过程缺省拦截器，将拦截所有service --><br>已知扩展<br>com.alibaba.dubbo.rpc.filter.EchoFilter<br>com.alibaba.dubbo.rpc.filter.GenericFilter<br>com.alibaba.dubbo.rpc.filter.GenericImplFilter<br>com.alibaba.dubbo.rpc.filter.TokenFilter<br>com.alibaba.dubbo.rpc.filter.AccessLogFilter<br>com.alibaba.dubbo.rpc.filter.CountFilter<br>com.alibaba.dubbo.rpc.filter.ActiveLimitFilter<br>com.alibaba.dubbo.rpc.filter.ClassLoaderFilter<br>com.alibaba.dubbo.rpc.filter.ContextFilter<br>com.alibaba.dubbo.rpc.filter.ConsumerContextFilter<br>com.alibaba.dubbo.rpc.filter.ExceptionFilter<br>com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter<br>com.alibaba.dubbo.rpc.filter.DeprecatedFilter</p>
<p>总结得比较简单，摘自我的培训课件，适合根据这个文章来做分享，欢迎大家一起交流。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/03/浅谈dubbo微服务/" data-id="cjyuyshdf0000ifs6rvk20lvp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/深入理解volatile/" class="article-date">
  <time datetime="2019-07-26T07:48:29.727Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/深入理解volatile/">深入理解volatile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#JMM Java 内存模型<br>Java的内存模型指定了Java虚拟机如何与计算机的内存进行工作<br><img src="https://upload-images.jianshu.io/upload_images/15507353-f6fa34679930e9c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系，具体如下：<br>1、共享变量存储在主内存中，每个线程都可以访问。<br>2、每个线程都有私有的工作内存。<br>3、工作内存只存储该线程对共享变量的副本。<br>4、线程不能直接操作主内存，只有先操作了工作内存之后才能写入内存。<br>      假设主内存的共享变量为0，线程1和线程2分享拥有共享变量X的副本，假设线程1此时将工作内存中的X修改为1，同时刷新到主内存中，当线程2想要去使用副本X的时候，就会发现该变量已经失效了，必须到主内存中再次获取然后存入自己的工作内容中，这一点和CPU与CPU Cache之间的关系非常类似。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-d1850faa3ea16741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当同一个数据被分别存储到了计算机的各个内存区域时，就会导致多个线程在各自的工作内存中看到的可能不一样。后面会讲到Java语言中如何保证不通线程对某个共享变量的可见性。</p>
<p>#多线程可见性例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/17.</span><br><span class="line"> */</span><br><span class="line">public class VolatileFoo &#123;</span><br><span class="line"></span><br><span class="line">    //init_value 的最大值</span><br><span class="line">    final static  int MAX  = 5 ;</span><br><span class="line"></span><br><span class="line">    //init_value 的初始值</span><br><span class="line">    static int init_value = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //启动一个Reader线程 ,当发现local_value 和 init_value 不同时,则输出 init_value 被修改的信息</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int localValue = init_value;</span><br><span class="line">                while (localValue &lt; MAX)&#123;</span><br><span class="line">                    if(init_value != localValue)&#123;</span><br><span class="line">                        System.out.printf(&quot;The init_value is updated to [%d]\n&quot;,init_value);</span><br><span class="line">                        //对localValue 进行重新赋值</span><br><span class="line">                        localValue = init_value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;Reader&quot;).start();</span><br><span class="line"></span><br><span class="line">        //启动Updater线程,主要用于对init_value的修改,当local_value&gt;=5的时候则退出生命周期</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int localValue = init_value;</span><br><span class="line">                while(localValue &lt; MAX)&#123;</span><br><span class="line">                    //修改init_value</span><br><span class="line">                    System.out.printf(&quot;The init_value will be changed to [%d]\n&quot;,++localValue);</span><br><span class="line">                    init_value = localValue;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //短暂休眠 目的是为了使Reader线程来得及输出变化内容</span><br><span class="line">                        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家先猜一下，运行结果是怎么样的？可能会大失所望<br>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/bin/java -Dvisualvm.id=83453442187216 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -Didea.launcher.port=7534 &quot;-Didea.launcher.bin.path=/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/tools.jar:/Users/bruce/2dfire/workspace/jvmstudy/target/classes:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain com.just.study.jvm.concurrent.VolatileFoo</span><br><span class="line">The init_value will be changed to [1]</span><br><span class="line">The init_value will be changed to [2]</span><br><span class="line">The init_value will be changed to [3]</span><br><span class="line">The init_value will be changed to [4]</span><br><span class="line">The init_value will be changed to [5]</span><br></pre></td></tr></table></figure>

<p>通过控制台的输出我们发现：Reader线程压根就没有感知到init_value的变化、并且进入了死循环线程没有退出<br>我们对代码做一个调整，将init_value变量设置为volatile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//init_value 的初始值</span><br><span class="line">static volatile int init_value = 0;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/bin/java -Dvisualvm.id=83688650193139 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -Didea.launcher.port=7535 &quot;-Didea.launcher.bin.path=/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/tools.jar:/Users/bruce/2dfire/workspace/jvmstudy/target/classes:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain com.just.study.jvm.concurrent.VolatileFoo</span><br><span class="line">The init_value will be changed to [1]</span><br><span class="line">The init_value is updated to [1]</span><br><span class="line">The init_value will be changed to [2]</span><br><span class="line">The init_value is updated to [2]</span><br><span class="line">The init_value will be changed to [3]</span><br><span class="line">The init_value is updated to [3]</span><br><span class="line">The init_value will be changed to [4]</span><br><span class="line">The init_value is updated to [4]</span><br><span class="line">The init_value will be changed to [5]</span><br><span class="line">The init_value is updated to [5]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>为啥会发生这样的改变、后面会慢慢讲到、这里是因为volatile可以保证多线程环境下的可见性、还有volatile的变量是先被写后再被读（后续会讲到）。</p>
<p>#CPU缓存模型和缓存一致性<br>CPU在速度上的发展要快与内存在速度上的发展，由于两边速度严重的不等，所以为了增加吞吐量，缩小CPU和内存的速度差，建立了CPU Cache模型，就是大家所熟知的L1、L2、L3 CPU高速缓存。CPU Cache又由很多个Cache Line构成，Cache Line可以认为是CPU Cache中最小的缓存单元。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-1c1459c4595a142e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15507353-c559c153d83f7a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>程序运行过程中，会将运算锁需要的数据从内存复制一份到CPU Cache中，然后进行读取和写入，当运算结束之后，在将CPU Cache中的最新数据刷新到内存中，这样通过CPU Cache在中间做交互，提高了CPU的吞吐能力。<br><img src="https://upload-images.jianshu.io/upload_images/15507353-5ec72c9d6d40d6fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>CPU Cache虽然提高了CPU的吞吐能力，同时也带来了一个问题：缓存不一致的问题，比如i++这个操作，运行的过程如下；<br>1、读取主内存的i到CPU Cache中。<br>2、对i进行加一的操作。<br>3、将结果写回到CPU Cache中。<br>4、将数据刷新到主内存中。<br>i++在单线程的情况下不会有任何问题，但在多线程的情况下就会有问题，每个线程都有自己的工作内存（对于于CPU的Cache），变量i会在多个线程的本地内存中都存在一个副本。如果同时有两个线程执行i++操作，假设i的初始值为0，每一个线程都从主内存获取i的值存入CPU Cache中，然后经过计算在写入主内存中，很有可能i在经过了两次自增之后结果还是1，这就是典型的缓存不一致问题。<br>主要有两种解决方法：<br>1、通过总线加锁。<br>2、通过缓存一致性协议。<br>第一种是悲观的实现方式，CPU和其他组件的通信都是通过总线来进行，会有阻塞，效率低下。</p>
<p>第二种：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-5d538923e3a0d23e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>在缓存一致性中最为出名的是Intel的MESI协议，MESI协议保证了每一个缓存汇中使用的是共享变量副本都是一致的，大概意思就是当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，也就是说在其他的CPU Cache中也存在一个副本，那么进行如下操作：<br>1、读取操作，不做任何处理，只是将Cache中的数据读取到寄存器。<br>2、写入操作，发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU在进行该变量读取的时候不得不到主内存中再次获取。</p>
<p>#并发编程三大特性：原子性、可见性、有序性</p>
<p>##原子性<br>原子性是值指在一次的操作或者多次操作中，要么所有的操作全部得到执行，要么所有的操作都不执行。i++ 是由三个原子操作组成get i, i+1 ,set i = x，但是i++就不是原子性操作。volatile不保证原子性，synchronized保证原子性，JUC的原子性类型保证原子性，例如：AtomicInteger，通过volatile和CAS来实现。</p>
<p>##可见性<br>可见性是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的新值。例如上面我们的例子Reader线程会将init_value从内存缓存到CPU Cache中，也就是从主内存缓存到线程的工作内存中，Updater线程对init_value的修改对Reader线程是不可见的。</p>
<p>##有序性<br>有序性就是程序代码在执行过程中的先后顺序，Java在编译器以及运行期的优化，会产生指令重排序，导致了代码的执行顺序不一定是编写代码时的顺序，指令重排序是在不影响运行结果的情况下进行重排序，对于单线程来说指令重排序不会有问题。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 0;</span><br><span class="line">x++;</span><br><span class="line">y=20;</span><br></pre></td></tr></table></figure>

<p>但是在多线程的情况下，如果有序性得不到保证，那么很有可能就会出现问题，例如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean initialized = false;</span><br><span class="line">private Context context = null;</span><br><span class="line">public Context load()&#123;</span><br><span class="line">     if(!initialized)&#123;</span><br><span class="line">        context = loadContext();</span><br><span class="line">        initialized = true;</span><br><span class="line">     &#125;</span><br><span class="line">     return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单线程情况，这段代码重排序，录入把   initialized = true;放到   context = loadContext();调换位置，不会有问题，但是如果多线程情况下第二个线程在调用load方法后可能会得到一个null。</p>
<p>#JMM如何保证原子性、可见性、有序性<br>JVM采用内存模型的机制来屏蔽哥哥平台与操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果。比如C语言中的整型变量，在某些平台下占用了两个字节的内存，在某些平台下则占用了四个字节的内存，Java则在任何平台下，int类型就是四个字节，这就是一直内存访问效果。</p>
<p>##JMM与原子性<br>在Java语言中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的。<br>1、x=10 原子操作<br>2、y=x  非原子操作【两个原子操作合在一起就不是原子操作】<br>     1）执行线程从主内存中读取x的值（如果在工作内存就直接从工作内存获取）<br>     2）在执行线程的工作内存中修改y的值为x,然后将y的值写入主内存之中。<br>3、y++ 自增操作 不是原子的，因为包含三个原子操作：<br>    1)执行线程从主内存中读取y的值（如果y已存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存中。<br>    2）在执行线程工作内存中为y执行加1的操作。<br>    3）将y的值写入主内存。<br>结论：<br>        a、多个原子性操作在一起就不在是原子性操作了。<br>        b、简单的读取和赋值操作是原子性操作，将一个变量赋给另外一个变量的操作不是原子性操作。<br>       c、Java内存模型只保证了基本读取和赋值的原子性操作，其他的均不保证，如果先更要使得某些代码片段具备原子性，需使用关键字synchronized,或者JUC中的lock。原子封装类：AtomicInteger等。<br>总结：volatile不具备保证原子性的语义</p>
<p>#JMM与可见性<br>在多线程的环境下，如果某个线程首次读取共享变量，首先到主内存获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后在刷新至主内存中。但是什么时候最新的值会被刷新至主内存是不太确定的，这就解释了为什么没有加volatile关键字的时候VolatileFoo中的Reader线程始终无法获取到init_value最新的变化。<br>Java提供三种方式来保证可见性：<br>1）使用关键字volatile，共享资源的读操作直接在内存中进行。写操作是先写工作内存，然后立刻刷新到主内存中。<br>2）synchronized保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中。<br>3）通过JUC提供的显示锁lock也能够保证可见性，Lock的lock防范能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放之前会将对变量的修改刷新到主内存当中。</p>
<p>注：1、JVM禁用JIT即时编译器的后多线程环境下共享变量也具有可见性<br>例如下面代码,如果添加JVM参数 -server -Djava.compiler=NONE  或者 -Xint 多线程环境下flag共享变量就具有可见性<br>       2、System.out.print() 输出流会加锁，也具有可见性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/26.</span><br><span class="line"> */</span><br><span class="line">public class Zuo &#123;</span><br><span class="line"></span><br><span class="line">    private static boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        flag = false;</span><br><span class="line">        System.out.println(&quot;flag set to false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void print() &#123;</span><br><span class="line">        while (flag) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#JMM与有序性<br>在Java内存模型中，允许编译器和处理器对指令进行重排序，在单线程的情况下，重排序不会有问题，但是多线程的情况下，会影响程序的正确运行。<br>Java提供了三种保证有序性的方式：</p>
<ul>
<li>使用关键字volatile。</li>
<li>synchronized关键字。</li>
<li>使用显示Lock。<br>后两者是采用同步。</li>
</ul>
<p>Java内存的天生有一些有序性规则-Happens-before原则。如果两个操作无法从happens-before推导出来，那么他们就无法保证有序性。</p>
<ul>
<li>程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后，虚拟机还是会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。</li>
<li>锁定规则：一个unlock操作要先行发生在对同一个锁的lock操作。</li>
<li>volatile变量规则：对一个变量的写操作要早与对这个变量之后的读操作。意思是一个变量volatile,一个线程对它进行读，一个线程对它进行写，写操作一定是先行发生于读操作。</li>
<li>传递规则：如果操作A先于操作B，而操作B又先于操作C，则A先于操作C。</li>
<li>线程启动规则：Thread对象的start()方法先行于线程的任何动作。</li>
<li>线程中断规则：对线程执行interrupt()方法肯定要优先于捕捉到中断信号，意<br> 思是如果线程收到了中断信号，那么在此之前势必要有interrupt()。</li>
<li>线程的终结规则：线程中所有的操作都要先行发生于线程的终止检测，意识是线程的任务执行，逻辑单元执行肯定要发生于线程死亡之前。</li>
<li>对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前，意思是先生后死。<br>总结：volatile关键字保证有序性<br>#volatile关键字深入解析<br>volatile具有两个语义：</li>
<li>保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修改的变量，另外一个线程会立即看到最新的值。</li>
<li>禁止对指令进行重排序操作。<br>（1）理解volatile保证可见性：<pre><code>VolatileFoo例子，Updater线程对init_value变量的每一次更改都会使得Reader线程能够看到(happens-before规则中，第三条volatile变量规则：对一个变量的写操作要早于对这个变量之后的读操作)，步骤：</code></pre></li>
</ul>
<ol>
<li>Reader线程从主内存获取init_value的值为0，并且将其缓存到本地工作内存中。</li>
<li>Updater线程将init_value的值在本地工作内存中修改为1，然后立即刷新至主内存中。</li>
<li>Reader线程在本地工作内存中的init_value失效。（反映到硬件上就是CPU Cache 的 Cache Line失效）</li>
<li>由于Reader线程的工作内存中的init_value失效，因此需要从主内存中从新读取init_value的值。<br>（2）理解volatile保证有序性<br>volatile关键字对有序性的保证比较粗暴，直接静止JVM和处理器对volatile关键字修改的指令重排序，但是对volatile前后无依赖关系的指令则可以随便怎么排序。<br>（3）理解volatile不保证原子性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/21.</span><br><span class="line"> * //没次的运行结果不一样,具体原因是 i++ 不是一个原子操作,i++操作分三步:</span><br><span class="line"> *    1、从主内存中获取i的值,然后魂村至线程工作内存中。</span><br><span class="line"> *    2、在线程工作内存中为进行加1的操作。</span><br><span class="line"> *    3、将i的最新值写入主内存中。</span><br><span class="line"> *    上面三个操作单独的每一个操作都是原子性操作,但是合起来就不是原子性操作了。</span><br><span class="line"> */</span><br><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    //使用volatile修改共享资源i</span><br><span class="line">    private static volatile  int i = 0;</span><br><span class="line">    //private static AtomicInteger i = new AtomicInteger(0);</span><br><span class="line">    //10个线程</span><br><span class="line">    private static final CountDownLatch latch  = new CountDownLatch(10);</span><br><span class="line"></span><br><span class="line">    private static void inc()&#123;</span><br><span class="line">          i++;</span><br><span class="line">        //i.addAndGet(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i&lt; 10;i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line"></span><br><span class="line">                    for (int x = 0; x &lt; 1000; x++)&#123;</span><br><span class="line">                        inc();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //使计算器减1</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //等待所有的线程完成工作</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/bin/java -Dvisualvm.id=89098433865570 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -Didea.launcher.port=7533 &quot;-Didea.launcher.bin.path=/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/lib/tools.jar:/Users/bruce/2dfire/workspace/jvmstudy/target/classes:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar&quot; com.intellij.rt.execution.application.AppMain com.just.study.jvm.concurrent.VolatileTest</span><br><span class="line">9656</span><br></pre></td></tr></table></figure>

<p>上面代码创建了10个线程，每个线程执行1000次对共享变量i的自增操作，但是最终结果可能不是10000，因为这段代码的 i++ 操作其实是3个原子操作合起来的，3个原子操作合起来就不是原子操作了。</p>
<p>#volatile的原理和实现机制<br>下面为OpenJDK下的unsafe.cpp源码，会发现被volatile装饰的变量存在于一个”lock”的前缀，源码如下：<br><img src="https://upload-images.jianshu.io/upload_images/15507353-90a36fe1093a17f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>#volatile的使用场景<br>虽然volatile有部分synchronized关键字的语义，但是volatile不可能完全替代synchronized关键字，因为volatile关键字不具备原子性操作语义，我们在使用volatile关键字的时候也是充分利用它的可见性以及有序性（防止重排序）特点。</p>
<ol>
<li>开关控制-利用可见性的特点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chiyuanjia on 2019/7/25.</span><br><span class="line"> */</span><br><span class="line">public class ThreadCloseable extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    //volatile 关键字保证了started线程的可见性</span><br><span class="line">    private volatile boolean started = true;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        while (started) &#123;</span><br><span class="line">            //do work</span><br><span class="line">            System.out.println(&quot;I am working&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        this.started = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>2.状态标记顺序性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//阻止重排序</span><br><span class="line">private volatile boolean initialized = false;</span><br><span class="line">private Context context;</span><br><span class="line">public Context load() &#123;</span><br><span class="line">    if(!initialized)&#123;</span><br><span class="line">        context = loadContext();</span><br><span class="line">        //如果这里的initialized变量不是volatile的，那么指令重排序后</span><br><span class="line">        //假设 initialized = true;重排到context = loadContext();之前多线程访问情况下就会出现问题</span><br><span class="line">        initialized = true;  </span><br><span class="line">    &#125;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.单例模式的double-check也利用了volatile的有序性</p>
<p>#volatile和synchronized对比<br>（1）使用上的区别</p>
<ul>
<li>volatile关键字只能用于修改实例变量或者类变量，不能用于修改方法以及方法参数和局部变量、常量等。</li>
<li>synchronized关键字不能用于对变量的修饰，只能用于修饰方法或者语句块。</li>
<li>volatile修饰的变量可以为null,synchronized关键字同步块的monitor对象不能为null。<br>(2)对原子性的保证</li>
<li>volatile无法保证原子性。</li>
<li>由于synchronized是一种排他的机制，因此被synchronized关键字修饰的同步代码是无法被中途打断的，因此其能够保证代码的原子性。<br>(3)对可见性的保证</li>
<li>两者均可以保证资源在多线程间的可见性，但是实现机制完全不同。</li>
<li>synchronized借助于JVM指令monitor enter 和 monitor exit对通过排他的方式使得同步代码串行化，在monitor exit时所有共享资源都会被刷新到主内存中。</li>
<li>相比较于synchronized关键字volatile使用机器指令(偏硬件)“lock;”的方式迫使其他线程工作内存中的数据失效，需要到主内存中进行再次加载。<br>（4）对有序性的保证</li>
<li>volatile关键字禁止JVM编译器以及处理器对其进行重排序。</li>
<li>虽然synchronized关键字所修饰的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修饰的代码中代码指令也会发生指令重排序的情况，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(this)&#123;</span><br><span class="line">     int x = 10;</span><br><span class="line">     int y =20;</span><br><span class="line">     x++;</span><br><span class="line">     y = y+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>x和y谁先定义谁最先进行运算，对结果没有影响。达到了最终的输出结果和代码编写顺序的一致性。<br>（5）其他</p>
<ul>
<li>volatile不会使线程陷入阻塞。</li>
<li>synchronized会使线程进入阻塞状态。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/26/深入理解volatile/" data-id="cjytpmaxu0000uas6dza7yjan" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/03/浅谈dubbo微服务/">浅谈dubbo微服务</a>
          </li>
        
          <li>
            <a href="/2019/07/26/深入理解volatile/">深入理解volatile</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 池元嘉<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>